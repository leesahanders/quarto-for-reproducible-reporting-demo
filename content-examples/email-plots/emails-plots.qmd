---
title: "Quarto Emails (with Connect): Including plots"
author: "Lisa Anders"
format: email
---

Make the magic happen: <https://docs.posit.co/connect/user/quarto/#email-customization> 

## Email notifications: Add plots n stuff

### Generate contents: a map

```{r}
library(ggplot2)
library(maps)

df <- data.frame(x = state.center$x, y = state.center$y,
                 state = state.name)

map_plot <- ggplot(df, aes(x = x, y = y)) + 
       geom_polygon(data = map_data("state"),
                    color = "white",
                    aes(x = long, y = lat,
                        fill = map_data("state")$region,
                        group = group)) +
       guides(fill = FALSE) + 
        geom_text(aes(x = -115, y = 25, label = "Map of the United States"),
                    stat = "unique") +
        geom_label(aes(label = state))

map_plot
```

### Generate contents: Good ol mtcars

```{r echo = FALSE}
library(ggplot2)
library(ggiraph)

# Create a ggplot object
mtcars_plot <- ggplot(mtcars, aes(x = wt, y = mpg, tooltip = paste("Weight:", wt, "MPG:", mpg), data_id = row.names(mtcars))) +
  geom_point_interactive()

mtcars_plot
```

Generate contents: Package Manager metrics 

> Please note that most of the above mentioned API Endpoints are not officially documented and not fully supported and hence can be subject to change in future versions of PPM. Any of those Endpoints however are visible via using Developer Tools in the web browser.

Reference the documentation on the server API either on your URL, or using the publicly available instance: <https://packagemanager.posit.co/__api__/swagger/index.html> 

For the hidden endpoints I'm referencing the proprietary source code: <https://github.com/rstudio/package-manager/tree/main/docs/api> and <https://github.com/rstudio/package-manager/tree/main/src/api> 

```{r echo = FALSE, results = 'hide', message=FALSE, warning=FALSE}
library(httr)
library(tidyr)
library(dplyr)
library(reactable)
library(DT)
library(stringr)

var_url = "https://packagemanager.posit.co/"
var_sources_internal_packages = c(161,9,5) # source id's for transaction information c(8,9,15,161,177)
var_repos_internal_packages = 8 # source id's for transaction information c(8,9,15,161,177)
var_repos_bioconductor = 4 # repository id for bioconductor #13
var_version_bioconductor = 3.16
lookback = 30 #days

```

Server Status

```{r}
#Server status 
resp <- GET(paste0(var_url, "__api__/status"), format="json")
status <- content(resp, type="application/json")

rspm_version <- status$version
```

Package Downloads 

PPM has an endpoint metrics/packages that allows you to get the download count of a given package for the last x days which should make it simple to expand this to date ranges. A sample call for package clustermq â€™s download stats for the last 112 days would look like

`curl "https://packagemanager.posit.co/__api__/metrics/packages?_sort=count&_order=desc&_days=112&_sourceType=r&name_like=clustermq"`

Even better would be to get the download stats for all R packages on PPM via

`curl "https://colorado.posit.co/rspm/__api__/metrics/packages?_sourceType=r&_days=112&_sort=count&_order=desc"`

If you want to extract the metrics between x and y days prior to today, you run the API call above twice and then simply subtract the numbers.

Total  sourceType r package downloads: 

```{r}
resp <- GET(paste0(var_url,"__api__/metrics/packages?_sourceType=r&_days=",lookback,"&_sort=count&_order=desc"), format="json")
metricsPackagesR <- content(resp, type="application/json")
metricsPackagesR <- unnest_wider(tibble::tibble(metricsPackagesR = metricsPackagesR), metricsPackagesR) 

metricsPackages %>% 
  summarize(count = sum(count))
```

Total  sourceType python package downloads:

```{r}
resp <- GET(paste0(var_url,"__api__/metrics/packages?_sourceType=python&_days=",lookback,"&_sort=count&_order=desc"), format="json")
metricsPackagesPython <- content(resp, type="application/json")
metricsPackagesPython <- unnest_wider(tibble::tibble(metricsPackagesPython = metricsPackagesPython), metricsPackagesPython)

metricsPackagesPython %>%
  summarize(count = sum(count))
```

By day cumulative sourceType r package downloads: 

Reference: 

- <https://r-charts.com/evolution/time-series-ggplot2/> 
- <https://stackoverflow.com/questions/61546244/reverse-engineering-cumulative-to-daily-data> 
- Color selection: <https://r-graph-gallery.com/ggplot2-color.html> 
- TODO: peaks and valleys <https://r-charts.com/evolution/time-series-ggplot2/> 

```{r}
library(plotly)
library(ggrepel)
#library(ggpmisc)

# Raw package data, cumulative from date
metricsPackagesR_daily_raw <- data.frame()
for(i in 1:lookback){
  resp <- GET(paste0(var_url,"__api__/metrics/packages?_sourceType=r&_days=",i,"&_sort=count&_order=desc"), format="json")
  
  metricsPackagesR_daily_tmp <- content(resp, type="application/json")
  metricsPackagesR_daily_tmp <- unnest_wider(tibble::tibble(metricsPackagesR_daily_tmp = metricsPackagesR_daily_tmp), metricsPackagesR_daily_tmp) %>% 
    mutate(lookback = i, date = Sys.Date()-lookback) %>%
    mutate(language ="R")
  
metricsPackagesR_daily_raw <- rbind(metricsPackagesR_daily_raw, metricsPackagesR_daily_tmp)
}

# Reverse engineer dailies from reverse cumulative 
metricsPackagesR_daily_raw <- metricsPackagesR_daily_raw %>% 
  group_by(name) %>%
  mutate(daily_count = c(count[1],diff(count)))

# Summary
metricsPackagesR_daily <- metricsPackagesR_daily_raw %>% group_by(lookback, date, language) %>%
  summarize(downloads = sum(daily_count)) %>%
  group_by(language) %>%
  arrange(date) %>% 
  mutate(cumulative_sum = cumsum(downloads))

# Area chart
plot_r_package_downloads <- ggplot(metricsPackagesR_daily) + 
  scale_x_date(date_labels = "%Y-%m-%d", date_breaks = "1 day") + 
  # Daily line
  geom_line(aes(x = date, y = downloads), 
            color = 4,      # Line color
            lwd = 0.5,      # Line width
            linetype = 1) + # Line type 
  geom_point(aes(x = date, y = downloads)) + 
  # Labels defined here
  geom_label_repel(
    data = metricsPackagesR_daily %>% filter(date == max(date)), 
    aes(date, downloads, label = "daily downloads"),
    box.padding = unit(0.35, "lines"),
    point.padding = unit(0.4, "lines"),
    color = "black",
    fill = "white") + 
  # Cumulative line 
  geom_line(aes(x = date, y = cumulative_sum), 
            color = 2,
            lwd = 1,  
            linetype = "dashed") +
  geom_point(aes(x = date, y = cumulative_sum)) + 
  ggtitle("Public Package Manager: R Downloads") + 
          #subtitle = "R Downloads") +  
  # Labels defined here
  geom_label_repel(
    data = metricsPackagesR_daily %>% filter(date == max(date)), 
    aes(date, cumulative_sum, label = "cumulative downloads"),
    box.padding = unit(0.35, "lines"),
    point.padding = unit(0.4, "lines"),
    color = "black",
    fill = "white") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        plot.margin = margin(t = 20,  # Top margin
                             r = 50,  # Right margin
                             b = 40,  # Bottom margin
                             l = 10)) # Left margin
  
plot_r_package_downloads
```

By day cumulative sourceType python package downloads:

```{r}
# Raw package data, cumulative from date
metricsPackagesPython_daily_raw <- data.frame()
for(i in 1:lookback){
  resp <- GET(paste0(var_url,"__api__/metrics/packages?_sourceType=python&_days=",i,"&_sort=count&_order=desc"), format="json")
  
  metricsPackagesPython_daily_tmp <- content(resp, type="application/json")
  metricsPackagesPython_daily_tmp <- unnest_wider(tibble::tibble(metricsPackagesPython_daily_tmp = metricsPackagesPython_daily_tmp), metricsPackagesPython_daily_tmp) %>% 
    mutate(lookback = i, date = Sys.Date()-lookback) %>%
    mutate(language ="Python")
  
metricsPackagesPython_daily_raw <- rbind(metricsPackagesPython_daily_raw, metricsPackagesPython_daily_tmp)
}

# Reverse engineer dailies from reverse cumulative 
metricsPackagesPython_daily_raw <- metricsPackagesPython_daily_raw %>% 
  group_by(name) %>%
  mutate(daily_count = c(count[1],diff(count)))

# Summary
metricsPackagesPython_daily <- metricsPackagesPython_daily_raw %>% group_by(lookback, date, language) %>%
  summarize(downloads = sum(daily_count)) %>%
  group_by(language) %>%
  arrange(date) %>% 
  mutate(cumulative_sum = cumsum(downloads))

# Area chart
plot_Python_package_downloads <- ggplot(metricsPackagesPython_daily) + 
  scale_x_date(date_labels = "%Y-%m-%d", date_breaks = "1 day") + 
  # Daily line
  geom_line(aes(x = date, y = downloads), 
            color = 4,      # Line color
            lwd = 0.5,      # Line width
            linetype = 1) + # Line type 
  geom_point(aes(x = date, y = downloads)) + 
  # Labels defined here
  geom_label_repel(
    data = metricsPackagesPython_daily %>% filter(date == max(date)), 
    aes(date, downloads, label = "daily downloads"),
    box.padding = unit(0.35, "lines"),
    point.padding = unit(0.4, "lines"),
    color = "black",
    fill = "white") + 
  # Cumulative line 
  geom_line(aes(x = date, y = cumulative_sum), 
            color = 2,
            lwd = 1,  
            linetype = "dashed") +
  geom_point(aes(x = date, y = cumulative_sum)) + 
  # Labels defined here
  geom_label_repel(
    data = metricsPackagesPython_daily %>% filter(date == max(date)), 
    aes(date, cumulative_sum, label = "cumulative downloads"),
    box.padding = unit(0.35, "lines"),
    point.padding = unit(0.4, "lines"),
    color = "black",
    fill = "white") + 
  ggtitle("Public Package Manager: Python Downloads") + 
          #subtitle = "Python Downloads") +  
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        plot.margin = margin(t = 20,  # Top margin
                             r = 50,  # Right margin
                             b = 40,  # Bottom margin
                             l = 10)) # Left margin

#plot_Python_package_downloads_plotly <- ggplotly(plot_Python_package_downloads) 
plot_Python_package_downloads
```


Packages with currently detected vulnerabilities






Send an email. 

::: {.email}

::: {.subject}
Here's some curated content for you
:::


Here's a map

```{r}
#| echo: false

map_plot
```

Here's good ol mtcars

```{r}
#| echo: false

mtcars_plot
```

:::



## Implementation notes

References: 

- <https://docs.posit.co/connect/user/quarto/index.html#email-customization> 
- <https://quarto.org/docs/authoring/conditional.html> 
- <https://github.com/rich-iannone/quarto-email/issues/9> 

### RSS feed details

Goal: Using the RSS feed from [the published sample blog](https://colorado.posit.co/rsc/connect/#/apps/1561d39e-977a-4e5c-9e73-857860b3d076/access) this quarto document will send an email when a new blog has been published. 

The [quarto RSS feed option](https://quarto.org/docs/websites/website-blog.html#rss-feed) will need to be enabled on the site that will be tracked. We can then use [tidyrss](https://robertmyles.github.io/tidyRSS/) to read the rss file back. 

This is using an example that was [deployed to Posit Connect](https://quarto.org/docs/publishing/rstudio-connect.html#publish-command) for the email generation with the [Connect Email Generation feature](https://quarto.org/docs/prerelease/1.4/email.html). 

Limitations: 

- This implementation currently doesn't have handling for authentication and only works with quarto blogs that have been published **anyone, no login required**. 
- What happens if the scheduling service is interrupted for some reason? Right now the lookback is still just for the last 1 day. Other options could be to `pin` the xml and use that to compare to what was available the last time it ran, or use `connectapi` to check when last it successfully ran and use that to generate a timeframe. 
- Email customization requires Quarto 1.4.